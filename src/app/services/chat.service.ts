// src/app/services/chat.service.ts

import { Injectable } from '@angular/core';
import {
  Database,
  ref,
  push,
  onValue,
  query,
  limitToLast,
  orderByChild,
  get,
  DataSnapshot,
} from '@angular/fire/database';
import { Observable } from 'rxjs';
import { ChatMessage } from '../models/models'; // Import ChatMessage from your models file

@Injectable({
  providedIn: 'root',
})
export class ChatService {
  constructor(private db: Database) {}

  /**
   * Constructs the full Realtime Database path for a project's messages.
   * This helper ensures consistency across send/receive operations.
   */
  private getProjectPath(
    organizationId: string,
    domainUid: string,
    projectId: string
  ): string {
    return `organizations/${organizationId}/domains/${domainUid}/projects/${projectId}/messages`;
  }

  /**
   * Sends a new message to a specific project's chat.
   * @param organizationId The ID of the organization.
   * @param domainUid The UID of the domain.
   * @param projectId The ID of the project the message belongs to.
   * @param senderId The UID of the sender.
   * @param senderEmail The email of the sender (for display).
   * @param messageText The content of the message.
   */
  async sendMessage(
    organizationId: string,
    domainUid: string,
    projectId: string,
    senderId: string,
    senderEmail: string,
    messageText: string
  ): Promise<void> {
    if (
      !organizationId ||
      !domainUid ||
      !projectId ||
      !senderId ||
      !senderEmail ||
      !messageText.trim()
    ) {
      console.error(
        'ChatService: Cannot send message: Missing required fields.'
      );
      throw new Error('Missing required message fields.');
    }

    const chatPath = this.getProjectPath(organizationId, domainUid, projectId); // obtaining project path
    const chatRef = ref(this.db, chatPath); // finding the reference of the rtdb collection

    const newMessage: Omit<ChatMessage, 'id'> = {
      // Omit 'id' as it's generated by push()
      senderId,
      senderEmail,
      messageText: messageText.trim(),
      timestamp: Date.now(), // Current Unix timestamp
    }; // creating new message

    try {
      await push(chatRef, newMessage); // pushing new message to rtdb
      console.log('ChatService: Message sent successfully to:', chatPath);
    } catch (error) {
      console.error('ChatService: Error sending message:', error);
      throw error;
    }
  }

  /**
   * Gets real-time updates for messages in a specific project's chat.
   * Orders messages by timestamp.
   * @param organizationId The ID of the organization.
   * @param domainUid The UID of the domain.
   * @param projectId The ID of the project to get messages for.
   * @param limit Optional: The maximum number of messages to retrieve (e.g., for initial load).
   * @returns An Observable of ChatMessage arrays.
   */
  getProjectMessages(
    organizationId: string,
    domainUid: string,
    projectId: string,
    limit?: number
  ): Observable<ChatMessage[]> {
    if (!organizationId || !domainUid || !projectId) {
      console.error(
        'ChatService: Cannot get messages: Missing organizationId, domainUid, or projectId.'
      );
      return new Observable<ChatMessage[]>((observer) => observer.next([])); // Return empty observable
    }

    const chatPath = this.getProjectPath(organizationId, domainUid, projectId); // obtains project path
    const chatRef = ref(this.db, chatPath); // finds chat ref

    let q = query(chatRef, orderByChild('timestamp')); // gets the ref ordered by timestamp values of the data in it

    if (limit) {
      q = query(chatRef, orderByChild('timestamp'), limitToLast(limit)); // adds ttl to the query
    }

    return new Observable<ChatMessage[]>((observer) => {
      // onValue listens for changes in the query and emits data when changed
      // here we find the data preset at that location and get a snapshot of it
      const unsubscribe = onValue(
        q,
        (snapshot: DataSnapshot) => {
          const messages: ChatMessage[] = [];
          snapshot.forEach((childSnapshot) => {
            // we are converting the snapshot value into chatmessage type
            const message = childSnapshot.val() as ChatMessage;
            messages.push({ ...message, id: childSnapshot.key || undefined });
            // pushing the message into the array of messages
          });
          observer.next(messages); // adds it into the observer
          // here the class Observable is like a stream which monitors continuously changing data
          // and on a change we can use it to get snapshots of the current states and modify it add to it
          // this is being done by using an observer , this is like dao , we use this to modify the observable data
          // this is auto declared on calling of when Observable class is used
          // chatmessages is an interface
        },
        (error) => {
          console.error(
            'ChatService: Error getting real-time messages:',
            error
          );
          observer.error(error);
        }
      );

      // Return a cleanup function to unsubscribe when the observable is no longer subscribed
      return () => unsubscribe();
    });
  }

  /**
   * Fetches a single message by its ID (less common for chat stream).
   * @param organizationId The ID of the organization.
   * @param domainUid The UID of the domain.
   * @param projectId The ID of the project.
   * @param messageId The ID of the message.
   * @returns A Promise that resolves to the ChatMessage or null if not found.
   */
  async getMessageById(
    organizationId: string,
    domainUid: string,
    projectId: string,
    messageId: string
  ): Promise<ChatMessage | null> {
    if (!organizationId || !domainUid || !projectId || !messageId) {
      console.error(
        'ChatService: Cannot fetch message by ID: Missing required path segments.'
      );
      return null;
    }
    const messagePath = `${this.getProjectPath(
      organizationId,
      domainUid,
      projectId
    )}/${messageId}`;
    const messageRef = ref(this.db, messagePath);
    try {
      const snapshot = await get(messageRef);
      if (snapshot.exists()) {
        return {
          ...(snapshot.val() as ChatMessage),
          id: snapshot.key || undefined,
        };
      }
      return null;
    } catch (error) {
      console.error('ChatService: Error fetching message by ID:', error);
      throw error;
    }
  }
}
